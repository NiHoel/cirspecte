/**
 * Rx.webworker.min.js (https://github.com/lsa2127291/rxjs-webworker/blob/master/src/observable/fromWorker.js)
 * */
!function (r, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t(r.RxWorker = {}) }(this, function (r) { "use strict"; var u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (r) { return typeof r } : function (r) { return r && "function" == typeof Symbol && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r }, e = function (r, t) { return (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (r, t) { r.__proto__ = t } || function (r, t) { for (var n in t) t.hasOwnProperty(n) && (r[n] = t[n]) })(r, t) }; function t(r, t) { function n() { this.constructor = r } e(r, t), r.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) } function p(r) { return "function" == typeof r } var n = !1, i = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(r) { r && (new Error).stack; n = r }, get useDeprecatedSynchronousErrorHandling() { return n } }; function o(r) { setTimeout(function () { throw r }) } var c = { closed: !0, next: function (r) { }, error: function (r) { if (i.useDeprecatedSynchronousErrorHandling) throw r; o(r) }, complete: function () { } }, f = Array.isArray || function (r) { return r && "number" == typeof r.length }; function h(r) { return null != r && "object" === (void 0 === r ? "undefined" : u(r)) } var s, b = { e: {} }; function a() { try { return s.apply(this, arguments) } catch (r) { return b.e = r, b } } function l(r) { return s = r, a } var y = function (n) { function e(r) { var t = n.call(this, r ? r.length + " errors occurred during unsubscription:\n  " + r.map(function (r, t) { return t + 1 + ") " + r.toString() }).join("\n  ") : "") || this; return t.errors = r, t.name = "UnsubscriptionError", Object.setPrototypeOf(t, e.prototype), t } return t(e, n), e }(Error), d = function () { function e(r) { this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, r && (this._unsubscribe = r) } var r; return e.prototype.unsubscribe = function () { var r, t = !1; if (!this.closed) { var n = this._parent, e = this._parents, o = this._unsubscribe, i = this._subscriptions; this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null; for (var s = -1, u = e ? e.length : 0; n;)n.remove(this), n = ++s < u && e[s] || null; if (p(o)) l(o).call(this) === b && (t = !0, r = r || (b.e instanceof y ? _(b.e.errors) : [b.e])); if (f(i)) for (s = -1, u = i.length; ++s < u;){ var c = i[s]; if (h(c)) if (l(c.unsubscribe).call(c) === b) { t = !0, r = r || []; var a = b.e; a instanceof y ? r = r.concat(_(a.errors)) : r.push(a) } } if (t) throw new y(r) } }, e.prototype.add = function (r) { if (!r || r === e.EMPTY) return e.EMPTY; if (r === this) return this; var t = r; switch (void 0 === r ? "undefined" : u(r)) { case "function": t = new e(r); case "object": if (t.closed || "function" != typeof t.unsubscribe) return t; if (this.closed) return t.unsubscribe(), t; if ("function" != typeof t._addParent) { var n = t; (t = new e)._subscriptions = [n] } break; default: throw new Error("unrecognized teardown " + r + " added to Subscription.") }return (this._subscriptions || (this._subscriptions = [])).push(t), t._addParent(this), t }, e.prototype.remove = function (r) { var t = this._subscriptions; if (t) { var n = t.indexOf(r); -1 !== n && t.splice(n, 1) } }, e.prototype._addParent = function (r) { var t = this._parent, n = this._parents; t && t !== r ? n ? -1 === n.indexOf(r) && n.push(r) : this._parents = [r] : this._parent = r }, e.EMPTY = ((r = new e).closed = !0, r), e }(); function _(r) { return r.reduce(function (r, t) { return r.concat(t instanceof y ? t.errors : t) }, []) } var v = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("rxSubscriber") : "@@rxSubscriber", w = function (s) { function o(r, t, n) { var e, o = s.call(this) || this; switch (o.syncErrorValue = null, o.syncErrorThrown = !1, o.syncErrorThrowable = !1, o.isStopped = !1, arguments.length) { case 0: o.destination = c; break; case 1: if (!r) { o.destination = c; break } if ("object" === (void 0 === r ? "undefined" : u(r))) { if ((e = r) instanceof w || "syncErrorThrowable" in e && e[v]) { var i = r[v](); o.syncErrorThrowable = i.syncErrorThrowable, (o.destination = i).add(o) } else o.syncErrorThrowable = !0, o.destination = new E(o, r); break } default: o.syncErrorThrowable = !0, o.destination = new E(o, r, t, n) }return o } return t(o, s), o.prototype[v] = function () { return this }, o.create = function (r, t, n) { var e = new o(r, t, n); return e.syncErrorThrowable = !1, e }, o.prototype.next = function (r) { this.isStopped || this._next(r) }, o.prototype.error = function (r) { this.isStopped || (this.isStopped = !0, this._error(r)) }, o.prototype.complete = function () { this.isStopped || (this.isStopped = !0, this._complete()) }, o.prototype.unsubscribe = function () { this.closed || (this.isStopped = !0, s.prototype.unsubscribe.call(this)) }, o.prototype._next = function (r) { this.destination.next(r) }, o.prototype._error = function (r) { this.destination.error(r), this.unsubscribe() }, o.prototype._complete = function () { this.destination.complete(), this.unsubscribe() }, o.prototype._unsubscribeAndRecycle = function () { var r = this._parent, t = this._parents; return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parent = r, this._parents = t, this }, o }(d), E = function (u) { function r(r, t, n, e) { var o, i = u.call(this) || this; i._parentSubscriber = r; var s = i; return p(t) ? o = t : t && (o = t.next, n = t.error, e = t.complete, t !== c && (p((s = Object.create(t)).unsubscribe) && i.add(s.unsubscribe.bind(s)), s.unsubscribe = i.unsubscribe.bind(i))), i._context = s, i._next = o, i._error = n, i._complete = e, i } return t(r, u), r.prototype.next = function (r) { if (!this.isStopped && this._next) { var t = this._parentSubscriber; i.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? this.__tryOrSetError(t, this._next, r) && this.unsubscribe() : this.__tryOrUnsub(this._next, r) } }, r.prototype.error = function (r) { if (!this.isStopped) { var t = this._parentSubscriber, n = i.useDeprecatedSynchronousErrorHandling; if (this._error) n && t.syncErrorThrowable ? this.__tryOrSetError(t, this._error, r) : this.__tryOrUnsub(this._error, r), this.unsubscribe(); else if (t.syncErrorThrowable) n ? (t.syncErrorValue = r, t.syncErrorThrown = !0) : o(r), this.unsubscribe(); else { if (this.unsubscribe(), n) throw r; o(r) } } }, r.prototype.complete = function () { var r = this; if (!this.isStopped) { var t = this._parentSubscriber; if (this._complete) { var n = function () { return r._complete.call(r._context) }; i.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? this.__tryOrSetError(t, n) : this.__tryOrUnsub(n), this.unsubscribe() } else this.unsubscribe() } }, r.prototype.__tryOrUnsub = function (r, t) { try { r.call(this._context, t) } catch (r) { if (this.unsubscribe(), i.useDeprecatedSynchronousErrorHandling) throw r; o(r) } }, r.prototype.__tryOrSetError = function (t, r, n) { if (!i.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { r.call(this._context, n) } catch (r) { return i.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0) : (o(r), !0) } return !1 }, r.prototype._unsubscribe = function () { var r = this._parentSubscriber; this._context = null, this._parentSubscriber = null, r.unsubscribe() }, r }(w); var S = "function" == typeof Symbol && Symbol.observable || "@@observable"; function m() { } var g = function () { function n(r) { this._isScalar = !1, r && (this._subscribe = r) } return n.prototype.lift = function (r) { var t = new n; return t.source = this, t.operator = r, t }, n.prototype.subscribe = function (r, t, n) { var e = this.operator, o = function (r, t, n) { if (r) { if (r instanceof w) return r; if (r[v]) return r[v]() } return r || t || n ? new w(r, t, n) : new w(c) }(r, t, n); if (e ? e.call(o, this.source) : o.add(this.source || i.useDeprecatedSynchronousErrorHandling && !o.syncErrorThrowable ? this._subscribe(o) : this._trySubscribe(o)), i.useDeprecatedSynchronousErrorHandling && o.syncErrorThrowable && (o.syncErrorThrowable = !1, o.syncErrorThrown)) throw o.syncErrorValue; return o }, n.prototype._trySubscribe = function (t) { try { return this._subscribe(t) } catch (r) { i.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = r), t.error(r) } }, n.prototype.forEach = function (e, r) { var o = this; return new (r = x(r))(function (r, t) { var n; n = o.subscribe(function (r) { try { e(r) } catch (r) { t(r), n && n.unsubscribe() } }, t, r) }) }, n.prototype._subscribe = function (r) { var t = this.source; return t && t.subscribe(r) }, n.prototype[S] = function () { return this }, n.prototype.pipe = function () { for (var t, r = [], n = 0; n < arguments.length; n++)r[n] = arguments[n]; return 0 === r.length ? this : ((t = r) ? 1 === t.length ? t[0] : function (r) { return t.reduce(function (r, t) { return t(r) }, r) } : m)(this) }, n.prototype.toPromise = function (r) { var e = this; return new (r = x(r))(function (r, t) { var n; e.subscribe(function (r) { return n = r }, function (r) { return t(r) }, function () { return r(n) }) }) }, n.create = function (r) { return new n(r) }, n }(); function x(r) { if (r || (r = i.Promise || Promise), !r) throw new Error("no Promise impl found"); return r } Error; Error, Error, Error; var T = new Map; r.fromWorker = function (n) { var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "init"; return g.create(function (t) { var r = void 0; if (n instanceof Worker) r = n; else try { r = function (r) { if ("string" == typeof r) return new Worker(r); var t = new Blob(["self.onmessage = ", r.toString()], { type: "text/javascript" }), n = URL.createObjectURL(t); return new Worker(n) }(n) } catch (r) { t.error(r) } r.onmessage = function (r) { t.next(r.data) }, r.onerror = function (r) { return t.error(r) }, r.postMessage(e) }) }, r.mapWorker = function (s) { return function (i) { return new g(function (t) { var r, n, e = s.toString(), o = void 0; return T.has(e) ? o = T.get(e) : (r = new Blob(["self.cb = ", s.toString(), ";", "self.onmessage = function (e) { self.postMessage(self.cb(e.data)) }"], { type: "text/javascript" }), n = URL.createObjectURL(r), o = new Worker(n), T.set(e, o)), o.onmessage = function (r) { return t.next(r.data) }, o.onerror = function (r) { return t.next(r) }, i.subscribe(function (r) { return o.postMessage(r) }) }) } }, Object.defineProperty(r, "__esModule", { value: !0 }) });